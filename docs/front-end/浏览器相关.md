---
title: 浏览器相关
date: 2019-11-04
sidebar: "auto"
categories:
  - front-end
tags:
  - browser
keys:
  - "bixin"
publish: false
---

# 浏览器相关

4.4 GET 和 POST 的区别
(1) GET 请求在浏览器回退和刷新时是无害的，而 POST 请求会告知用户数据会被重新提交；
(2) GET 请求可以收藏为书签，POST 请求不可以收藏为书签；
(3) GET 请求可以被缓存，POST 请求不可以被缓存，除非在响应头中包含合适的 Cache-Control/Expires 字段，但是不建议缓存 POST 请求，其不满足幂等性，每次调用都会对服务器资源造成影响；
(4) GET 请求一般不具有请求体，因此只能进行 url 编码，而 POST 请求支持多种编码方式。
(5) GET 请求的参数可以被保留在浏览器的历史中，POST 请求不会被保留；
(6) GET 请求因为是向 URL 添加数据，不同的浏览器厂商，代理服务器，web 服务器都可能会有自己的长度限制，而 POST 请求无长度限制；
(7) GET 请求只允许 ASCII 字符，POST 请求无限制，支持二进制数据；
(8) GET 请求的安全性较差，数据被暴露在浏览器的 URL 中，所以不能用来传递敏感信息，POST 请求的安全性较好，数据不会暴露在 URL 中；
(9) GET 请求具有幂等性(多次请求不会对资源造成影响)，POST 请求不幂等；
(10) GET 请求一般不具有请求体，请求中一般不包含 100-continue 协议，所以只会发一次请求，而 POST 请求在发送数据到服务端之前允许双方"握手"，客户端先发送 Expect:100-continue 消息，询问服务端是否愿意接收数据，接收到服务端正确的 100-continue 应答后才会将请求体发送给服务端，服务端再响应 200 返回数据。

4.5 说下浏览器的缓存机制
浏览器的缓存机制可分为强缓存和协商缓存，服务端可以在响应头中增加 Cache-Control/Expires 来为当前资源设置缓存有效期(Cache-Control 的 max-age 的优先级高于 Expires)，浏览器再次发送请求时，会先判断缓存是否过期，如果未过期则命中强缓存，直接使用浏览器的本地缓存资源，如果已过期则使用协商缓存，协商缓存大致有以下两种方案：
(1) 唯一标识：Etag(服务端响应携带) & If-None-Match(客户端请求携带)；
(2) 最后修改时间： Last-Modified(服务端响应携带) & If-Modified-Since (客户端请求携带) ，其优先级低于 Etag。
服务端判断值是否一致，如果一致，则直接返回 304 通知浏览器使用本地缓存，如果不一致则返回新的资源。

5.6 跨标签页的通讯方式有哪些
(1) BroadCast Channel
(2) Service Worker
(3) LocalStorage + window.onstorage 监听
(4) Shared Worker + 定时器轮询(setInterval)
(5) IndexedDB + 定时器轮询(setInterval)
(6) cookie + 定时器轮询(setInterval)
(7) window.open + window.postMessage
(8) Websocket

<br/>
<Valine></Valine>
