---
title: 扯框架
date: 2019-07-09
sidebar: "auto"
categories:
  - front-end
tags:
  - interview
# publish: false
---

![](https://i.loli.net/2019/12/09/DkqOGuAF6SdBEWR.jpg)



> vue  部分

## virtual dom

用js来模拟DOM中的节点。

Virtual DOM 其实就是一个简单的 JS 对象，最少包含标签名(tag)、属性(attrs)和子元素对象(children)三个属性来描述节点，实际上它只是一层对真实 DOM 的抽象。

![](https://i.loli.net/2019/12/09/SPGDABwkCtanuQm.png)

#### 优点：

- 具备跨平台的优势
- 操作 DOM 慢，js 运行效率高。我们可以将 DOM 对比操作放在 JS 层，提高效率
- 提升渲染性能

#### [详解vue的diff算法](https://juejin.im/post/5affd01551882542c83301da)



## key 属性的作用和重要性

- 在渲染元素列表时，默认采用就地复用策略(无 key 情况)，性能更好，因为不需要创建和销毁 vnode，不需要在 dom 中添加移除节点。
- 而 key 的作用就是更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。
- 但是一般列表组件都有自己的状态。例如：一个新闻列表，可点击列表项来将其标记为"已访问"，可通过 tab 切换“娱乐新闻”或是“社会新闻”。无 key 则复用会保留之前状态而出错，带 key 则替换组件拥有正确状态。
- 所以 key 的作用主要是为了高效的更新虚拟 DOM，并且保证组件状态正确。



## 双向绑定的原理是什么

- Vue 的双向数据绑定是由数据劫持结合发布者订阅者实现的。数据劫持是通过 Object.defineProperty()来劫持对象数据的 setter 和 getter 操作
- 原理: 通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化->视图更新
  在初始化 vue 实例时，遍历 data 这个对象，给每一个键值对利用 Object.definedProperty 对 data 的键值对新增 get 和 set 方法，利用了事件监听 DOM 的机制，让视图去改变数据



vue实现数据双向绑定主要是：采**用数据劫持结合发布者-订阅者模式**的方式，通过**Object.defineProperty（）**来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。



## 指令

| 指令          | 作用               |
| ------------- | ------------------ |
| v-html        | 输出真正的 HTML    |
| v-text        | 将数据解析为纯文本 |
| v-if / v-else | 条件渲染           |
| v-show        | 切换 display: none |
| v-for         | 列表渲染           |
| v-bind / :    | 属性绑定           |
| v-on / @      | 事件绑定           |
|               |                    |

#### 自定义指令

```vue
// 全局定义
Vue.directive("change-color",function(el,binding,vnode){
  el.style["color"]= binding.value;
})

// 使用
<template>
<div v-change-color=“color”>{{message}}</div>
</template>
<script>
  export default{
    data(){
      return{
        color:'green'
      }
    }
  }
</script>
```





## 生命周期

Vue 实例从 开始创建、初始化数据、编译模板、挂载DOM-渲染、更新-渲染、卸载等一系列的过程。

| 名称          | 解释                               |
| ------------- | ---------------------------------- |
| beforeCreate  | 未初始化                           |
| created       | 可访问数据和方法                   |
| beforeMount   | 未挂载，仍为虚拟 dom 节点          |
| mounted       | 挂载到真实 dom 上，可进行 dom 操作 |
| beforeUpdate  | 更新前                             |
| updated       | 更新 dom 后                        |
| beforeDestroy | 移除监听，定时器、事件等           |
| destroyed     | 实例销毁                           |

- beforeCreate：创建前，此阶段为实例初始化之后，this指向创建的实例，此时的数据观察事件机制都未形成，不能获得DOM节点。

  data，computed，watch，methods 上的方法和数据均不能访问。

  可以在这加个loading事件。

- created：创建后，此阶段为实例已经创建，完成数据（data、props、computed）的初始化导入依赖项。

  可访问 data computed watch methods 上的方法和数据。

  初始化完成时的事件写在这里，异步请求也适宜在这里调用（请求不宜过多，避免白屏时间太长）。

  可以在这里结束loading事件，还做一些初始化，实现函数自执行。

  未挂载DOM，若在此阶段进行DOM操作一定要放在Vue.nextTick()的回调函数中。

- beforeMount：挂载前，虽然得不到具体的DOM元素，但vue挂载的根节点已经创建，下面vue对DOM的操作将围绕这个根元素继续进行。

  beforeMount这个阶段是过渡性的，一般一个项目只能用到一两次。

- mounted：挂载，完成创建vm.$el，和双向绑定

  完成挂载DOM和渲染，可在mounted钩子函数中对挂载的DOM进行操作。

  可在这发起后端请求，拿回数据，配合路由钩子做一些事情。

- beforeUpdate：数据更新前，数据驱动DOM。

  在数据更新后虽然没有立即更新数据，但是DOM中的数据会改变，这是vue双向数据绑定的作用。

  可在更新前访问现有的DOM，如手动移出添加的事件监听器。

- updated：数据更新后，完成虚拟DOM的重新渲染和打补丁。

  组件DOM已完成更新，可执行依赖的DOM操作。

  注意：不要在此函数中操作数据（修改属性），会陷入死循环。

- activated：在使用vue-router时有时需要使用`<keep-alive></keep-alive>`来缓存组件状态，这个时候created钩子就不会被重复调用了。

  如果我们的子组件需要在每次加载的时候进行某些操作，可以使用activated钩子触发。

- deactivated：`<keep-alive></keep-alive>`组件被移除时使用。

- beforeDestroy：销毁前，

  可做一些删除提示，如：您确定删除xx吗？

- destroyed：销毁后，当前组件已被删除，销毁监听事件，组件、事件、子实例也被销毁。

  这时组件已经没有了，无法操作里面的任何东西了。

#### 父子组件的生命周期

[codepan](https://codesandbox.io/s/nostalgic-meninsky-f5kcm)

- 执行顺序： 

  - 父组件开始执行到beforeMount 然后开始子组件执行，最后是父组件mounted。

  - 如果有兄弟组件，父组件开始执行到beforeMount，然后兄弟组件依次执行到beforeMount，然后按照顺序执行mounted，最后执行父组件的mounted。

    ```js
    // 首次加载
    父: beforeCreate 
    父: created 
    父: beforeMount 
    --子1: beforeCreate 
    --子1: created 
    --子1: beforeMount 
    ----子2: beforeCreate 
    ----子2: created 
    ----子2: beforeMount 
    --子1: mounted 
    ----子2: mounted 
    父: mounted 
    ```

- 父子组件在data变化中是分别监控的，但是更新props中的数据是关联的。

  ```js
  // 父组件更新传到子组件的props
  父: beforeUpdate 
  --子1: beforeUpdate 
  ----子2: beforeUpdate 
  ----子2: updated 
  --子1: updated 
  父: updated 
  ```

- 销毁父组件时，先将子组件销毁后才会销毁父组件。

  ```js
  // 卸载父组件
  父: beforeDestroy 
  --子1: beforeDestroy 
  --子1: destroyed 
  ----子2: beforeDestroy 
  ----子2: destroyed 
  父: destroyed 
  ```

- 兄弟组件的初始化（mounted之前）是分开进行，挂载是从上到下依次进行

- 当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的

#### 声明周期的简单梳理

- `_init_`
  - `initLifecycle/Event`，往`vm`上挂载各种属性
  - `beforeCreate`: 实例刚创建
  - `initInjection/initState`: 初始化注入和 data 响应性
  - `created`: 创建完成，属性已经绑定， 但还未生成真实`dom`
  - 进行元素的挂载： `$el / vm.$mount()`
  - 是否有 `template`: 解析成 `render function`
    - `*.vue`文件: `vue-loader`会将`<template>`编译成`render function`
  - `beforeMount`: 模板编译/挂载之前
  - 执行`render function`，生成真实的`dom`，并替换到`dom tree`中
  - `mounted`: 组件已挂载
- `update`:
  - 执行`diff`算法，比对改变是否需要触发UI更新
  - `flushScheduleQueue`
    - `watcher.before`: 触发`beforeUpdate`钩子 - `watcher.run()`: 执行`watcher`中的 `notify`，通知所有依赖项更新UI
  - 触发`updated`钩子: 组件已更新
- `actived / deactivated(keep-alive)`: 不销毁，缓存，组件激活与失活
- `destroy`:
  - `beforeDestroy`: 销毁开始
  - 销毁自身且递归销毁子组件以及事件监听 
    - `remove()`: 删除节点
    - `watcher.teardown()`: 清空依赖
    - `vm.$off()`: 解绑监听
  - `destroyed`: 完成后触发钩子



#### 代码形式展示`vue`的初始化

```js
new Vue({})

// 初始化Vue实例
function _init() {
	 // 挂载属性
    initLifeCycle(vm) 
    // 初始化事件系统，钩子函数等
    initEvent(vm) 
    // 编译slot、vnode
    initRender(vm) 
    // 触发钩子
    callHook(vm, 'beforeCreate')
    // 添加inject功能
    initInjection(vm)
    // 完成数据响应性 props/data/watch/computed/methods
    initState(vm)
    // 添加 provide 功能
    initProvide(vm)
    // 触发钩子
    callHook(vm, 'created')
		
	 // 挂载节点
    if (vm.$options.el) {
        vm.$mount(vm.$options.el)
    }
}

// 挂载节点实现
function mountComponent(vm) {
	 // 获取 render function
    if (!this.options.render) {
        // template to render
        // Vue.compile = compileToFunctions
        let { render } = compileToFunctions() 
        this.options.render = render
    }
    // 触发钩子
    callHook('beforeMounte')
    // 初始化观察者
    // render 渲染 vdom， 
    vdom = vm.render()
    // update: 根据 diff 出的 patchs 挂载成真实的 dom 
    vm._update(vdom)
    // 触发钩子  
    callHook(vm, 'mounted')
}

// 更新节点实现
funtion queueWatcher(watcher) {
	nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
	 // 遍历队列中所有修改
    for(){
	    // beforeUpdate
        watcher.before()
         
        // 依赖局部更新节点
        watcher.update() 
        callHook('updated')
    }
}

// 销毁实例实现
Vue.prototype.$destory = function() {
	 // 触发钩子
    callHook(vm, 'beforeDestory')
    // 自身及子节点
    remove() 
    // 删除依赖
    watcher.teardown() 
    // 删除监听
    vm.$off() 
    // 触发钩子
    callHook(vm, 'destoryed')
}
```



## 组件通信

- props / $emit
- $children / $parent
- provide/ inject
- ref / refs
- eventBus
- Vuex
- localStorage / sessionStorage
- $attrs与 $listeners

#### 总结

- 父子组件通信: `props`; `$parent` / `$children`; `provide` / `inject` ; `ref` ;  `$attrs` / `$listeners`

- 兄弟组件通信: `eventBus` ;  Vuex

- 跨级通信:  `eventBus`；Vuex；`provide` / `inject` 、`$attrs` / `$listeners`

[vue中8种组件通信方式](https://juejin.im/post/5d267dcdf265da1b957081a3)



## vuex 流程及核心概念

#### 流程

- 页面通过 mapAction 异步提交事件到 action
- action 通过 commit 把对应参数同步提交到 mutation
- mutation 会修改 state 中对应的值
- 最后通过 getter 把对应值抛出去，在页面的计算属性中通过 mapGetter 来动态获取 state 中的值

#### 核心概念

- state: 保存着共有数据，数据是响应式的
- getter: 可以对 state 进行计算操作，主要用来过滤一些数据，可以在多组件之间复用
- mutations: 动态修改 state 中的数据，通过 commit 提交方法，方法必须是同步的
- actions: 通过 commit 提交 mutations，进行修改数据，可以包含任意异步操作；在组件 methods 中 mapActions 分发 action
- modules: 模块化 vuex



## nextTick

> 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

Vue 在修改数据后，视图不会立刻更新，而是等**同一事件循环**中的所有数据变化完成之后，再统一进行视图更新。

在vue中使用了三种情况来延迟调用该函数，

- 首先我们会判断我们的设备是否支持Promise对象，如果支持的话，会使用 Promise.then 来做延迟调用函数。
- 如果设备不支持Promise对象，再判断是否支持 MutationObserver 对象，如果支持该对象，就使用MutationObserver来做延迟，
- 最后如果上面两种都不支持的话，会使用` setTimeout(() => {}, 0);` setTimeout 来做延迟操作。

#### 使用场景

- 在created生命周期中进行DOM操作
- 更改数据后，进行节点DOM操作

[理解Vue.nextTick使用及源码分析](https://www.cnblogs.com/tugenhua0707/p/11756584.html)

[你真的理解$nextTick么](https://juejin.im/post/5cd9854b5188252035420a13)

[Vue.nextTick 的原理和用途](https://segmentfault.com/a/1190000012861862)



#### 响应式的数据for循环改变了1000次为什么视图只更新了一次

- Vue 异步执行 DOM 更新

- 只要观察到数据变化，Vue 将开启一个异步队列，并缓冲在同一事件循环中发生的所有数据改变

- 如果同一个 watcher 被多次触发，只会被推入到队列中一次
- 然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际工作
- Vue 在内部尝试对异步队列使用原生的 `Promise.then` 和 `MessageChannel`，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替

[Vue的数据为什么频繁变化但只会更新一次](https://juejin.im/post/5d690c726fb9a06b155dd40d#heading-140)



## watch 和 computed

#### watch的实现原理

watch的分类：

- deep watch（深层次监听）
- user watch（用户监听）
- computed watcher（计算属性）
- sync watcher（同步监听）

watch实现过程：

- watch的初始化在data初始化之后（此时的data已经通过`Object.defineProperty`的设置成响应式）
- watch的key会在Watcher里进行值的读取，也就是立马执行get获取value（从而实现data对应的key执行getter实现对于watch的依赖收集），此时如果有`immediate`属性那么立马执行watch对应的回调函数
- 当data对应的key发生变化时，触发user watch实现watch回调函数的执行

#### computed运行原理

- computed的属性是动态挂载到vm实例上的，和普通的响应式数据在data里声明不同
- 设置computed的getter，如果执行了computed对应的函数，由于函数会读取data属性值，因此又会触发data属性值的getter函数，在这个执行过程中就可以处理computed相对于data的依赖收集关系了
- 首次计算computed的值时，会执行vm.computed属性对应的getter函数（用户指定的computed函数，如果没有设置getter，那么将当前指定的函数赋值computed属性的getter），进行上述的依赖收集
- 如果computed的属性值又依赖了其他computed计算属性值，那么会将当前target暂存到栈中，先进行其他computed计算属性值的依赖收集，等其他计算属性依赖收集完成后，在从栈中pop出来，继续进行当前computed的依赖收集

```js
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```

由于 `this.firstName` 和 `this.lastName` （上面是Vue官方示例）都是响应式变量，因此会触发它们的 getter，根据我们之前的分析，它们会把自身持有的 dep 添加到当前正在计算的 watcher 中，这个时候`Dep.target`就是这个 computed watcher，具体步骤如下：

- data 属性初始化 getter setter
- computed 计算属性初始化，提供的函数将用作属性 `vm.fullName` 的 getter
- 当首次获取 `fullName` 计算属性的值时，Dep 开始依赖收集
- 在执行 message getter 方法时，如果 Dep 处于依赖收集状态，则判定`firstName`和`lastName`为`fullName`  的依赖，并建立依赖关系
- 当`firstName`或`lastName` 发生变化时，根据依赖关系，触发 `fullName` 的重新计算
- 如果计算值没有发生变化，不会触发视图更新

通过以上的分析，我们知道计算属性本质上就是一个 computed watcher，也了解了它的创建过程和被访问触发 getter 以及依赖更新的过程，其实这是最新的计算属性的实现，之所以这么设计是因为 Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化才会触发渲染 watcher 重新渲染，本质上是一种优化。

#### computed实现

从两个问题出发：

- 建立与其他属性（如：data、 Store）的联系；
- 属性改变后，通知计算属性重新计算。

实现时，主要如下

- 初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter/setter。
- 初始化 computed, 遍历 computed 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。
- Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。
- 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集

[搞懂computed和watch原理，减少使用场景思考时间](https://juejin.im/post/5d629380518825121f661973)

[Vue.js的computed和watch是如何工作的？](https://juejin.im/post/5b87f13bf265da436479f3c1)



## mixin

Mixins 使我们能够为 Vue 组件编写可插拔和可重用的功能。

如果你希望在多个组件之间重用一组组件选项，例如生命周期 hook、方法等，则可以将其编写为 mixin，并在组件中简单地引用它。然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优先于组件自己的 hook 。

缺点：命名冲突、隐式依赖



## Proxy 相比于 defineProperty 的优势

- 数组变化也能监听到
- 不需要深度遍历监听



- [Vue 开发必须知道的 36 个技巧【近1W字】](https://juejin.im/post/5d9d386fe51d45784d3f8637)