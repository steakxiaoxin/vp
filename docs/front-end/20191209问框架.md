---
title: 问框架
date: 2019-12-09
sidebar: "auto"
categories:
  - front-end
tags:
  - interview
# keys:
#   - "bixin"
publish: false
# sticky: true
---

![](https://i.loli.net/2019/12/09/DkqOGuAF6SdBEWR.jpg)

## vue 问题

### 1、key 属性的作用和重要性

- 在渲染元素列表时，默认采用就地复用策略(无 key 情况)，性能更好，因为不需要创建和销毁 vnode，不需要在 dom 中添加移除节点。
- 而 key 的作用就是更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。
- 但是一般列表组件都有自己的状态。例如：一个新闻列表，可点击列表项来将其标记为"已访问"，可通过 tab 切换“娱乐新闻”或是“社会新闻”。无 key 则复用会保留之前状态而出错，带 key 则替换组件拥有正确状态。
- 所以 key 的作用主要是为了高效的更新虚拟 DOM，并且保证组件状态正确。



### 2、指令

- v-html: 输出真正的 HTML
- v-text: 将数据解析为纯文本



### 3、生命周期

- beforeCreate: 未初始化
- created: 可访问数据和方法
- beforeMount: 未挂载，仍为虚拟 dom 节点
- mounted: 挂载到真实 dom 上，可进行 dom 操作
- beforeUpdate: 更新前
- updated: 更新 dom 后
- beforeDestroy: 移除监听，定时器、事件等
- destroyed: 实例销毁



#### 声明周期的简单梳理

- `_init_`
  - `initLifecycle/Event`，往`vm`上挂载各种属性
  - `beforeCreate`: 实例刚创建
  - `initInjection/initState`: 初始化注入和 data 响应性
  - `created`: 创建完成，属性已经绑定， 但还未生成真实`dom`
  - 进行元素的挂载： `$el / vm.$mount()`
  - 是否有 `template`: 解析成 `render function`
    - `*.vue`文件: `vue-loader`会将`<template>`编译成`render function`
  - `beforeMount`: 模板编译/挂载之前
  - 执行`render function`，生成真实的`dom`，并替换到`dom tree`中
  - `mounted`: 组件已挂载
- `update`:
  - 执行`diff`算法，比对改变是否需要触发UI更新
  - `flushScheduleQueue`
    - `watcher.before`: 触发`beforeUpdate`钩子 - `watcher.run()`: 执行`watcher`中的 `notify`，通知所有依赖项更新UI
  - 触发`updated`钩子: 组件已更新
- `actived / deactivated(keep-alive)`: 不销毁，缓存，组件激活与失活
- `destroy`:
  - `beforeDestroy`: 销毁开始
  - 销毁自身且递归销毁子组件以及事件监听 
    - `remove()`: 删除节点
    - `watcher.teardown()`: 清空依赖
    - `vm.$off()`: 解绑监听
  - `destroyed`: 完成后触发钩子



#### 代码形式展示`vue`的初始化

```js
new Vue({})

// 初始化Vue实例
function _init() {
	 // 挂载属性
    initLifeCycle(vm) 
    // 初始化事件系统，钩子函数等
    initEvent(vm) 
    // 编译slot、vnode
    initRender(vm) 
    // 触发钩子
    callHook(vm, 'beforeCreate')
    // 添加inject功能
    initInjection(vm)
    // 完成数据响应性 props/data/watch/computed/methods
    initState(vm)
    // 添加 provide 功能
    initProvide(vm)
    // 触发钩子
    callHook(vm, 'created')
		
	 // 挂载节点
    if (vm.$options.el) {
        vm.$mount(vm.$options.el)
    }
}

// 挂载节点实现
function mountComponent(vm) {
	 // 获取 render function
    if (!this.options.render) {
        // template to render
        // Vue.compile = compileToFunctions
        let { render } = compileToFunctions() 
        this.options.render = render
    }
    // 触发钩子
    callHook('beforeMounte')
    // 初始化观察者
    // render 渲染 vdom， 
    vdom = vm.render()
    // update: 根据 diff 出的 patchs 挂载成真实的 dom 
    vm._update(vdom)
    // 触发钩子  
    callHook(vm, 'mounted')
}

// 更新节点实现
funtion queueWatcher(watcher) {
	nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
	 // 遍历队列中所有修改
    for(){
	    // beforeUpdate
        watcher.before()
         
        // 依赖局部更新节点
        watcher.update() 
        callHook('updated')
    }
}

// 销毁实例实现
Vue.prototype.$destory = function() {
	 // 触发钩子
    callHook(vm, 'beforeDestory')
    // 自身及子节点
    remove() 
    // 删除依赖
    watcher.teardown() 
    // 删除监听
    vm.$off() 
    // 触发钩子
    callHook(vm, 'destoryed')
}
```



### 4、双向绑定的原理是什么

- Vue 的双向数据绑定是由数据劫持结合发布者订阅者实现的。数据劫持是通过 Object.defineProperty()来劫持对象数据的 setter 和 getter 操作
- 原理: 通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化->视图更新
  在初始化 vue 实例时，遍历 data 这个对象，给每一个键值对利用 Object.definedProperty 对 data 的键值对新增 get 和 set 方法，利用了事件监听 DOM 的机制，让视图去改变数据



### 5、mixin

Mixins 使我们能够为 Vue 组件编写可插拔和可重用的功能。

如果你希望在多个组件之间重用一组组件选项，例如生命周期 hook、方法等，则可以将其编写为 mixin，并在组件中简单地引用它。然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优先于组件自己的 hook 。

缺点：命名冲突、隐式依赖



### 6、virtual dom

Virtual DOM 其实就是一个简单的 JS 对象，最少包含标签名(tag)、属性(attrs)和子元素对象(children)三个属性来描述节点，实际上它只是一层对真实 DOM 的抽象。

![](https://i.loli.net/2019/12/09/SPGDABwkCtanuQm.png)

优点：

- 具备跨平台的优势
- 操作 DOM 慢，js 运行效率高。我们可以将 DOM 对比操作放在 JS 层，提高效率
- 提升渲染性能



### 7、vuex 流程及核心概念

流程：

- 页面通过 mapAction 异步提交事件到 action
- action 通过 commit 把对应参数同步提交到 mutation
- mutation 会修改 state 中对应的值
- 最后通过 getter 把对应值抛出去，在页面的计算属性中通过 mapGetter 来动态获取 state 中的值

核心概念

- state: 保存着共有数据，数据是响应式的
- getter: 可以对 state 进行计算操作，主要用来过滤一些数据，可以在多组件之间复用
- mutations: 动态修改 state 中的数据，通过 commit 提交方法，方法必须是同步的
- actions: 通过 commit 提交 mutations，进行修改数据，可以包含任意异步操作；在组件 methods 中 mapActions 分发 action
- modules: 模块化 vuex



### 8、nextTick

在下次`dom`更新循环结束之后执行延迟回调，可用于获取更新后的`dom`状态

- 新版本中默认是`microtasks`, `v-on`中会使用`macrotasks`
- `macrotasks`任务的实现:
  - `setImmediate / MessageChannel / setTimeout`

[占坑](https://juejin.im/post/5cd9854b5188252035420a13)



### 9、watch 和 computed

#### watch的实现原理

watch的分类：

- deep watch（深层次监听）
- user watch（用户监听）
- computed watcher（计算属性）
- sync watcher（同步监听）

watch实现过程：

- watch的初始化在data初始化之后（此时的data已经通过`Object.defineProperty`的设置成响应式）
- watch的key会在Watcher里进行值的读取，也就是立马执行get获取value（从而实现data对应的key执行getter实现对于watch的依赖收集），此时如果有`immediate`属性那么立马执行watch对应的回调函数
- 当data对应的key发生变化时，触发user watch实现watch回调函数的执行

#### computed运行原理

- computed的属性是动态挂载到vm实例上的，和普通的响应式数据在data里声明不同
- 设置computed的getter，如果执行了computed对应的函数，由于函数会读取data属性值，因此又会触发data属性值的getter函数，在这个执行过程中就可以处理computed相对于data的依赖收集关系了
- 首次计算computed的值时，会执行vm.computed属性对应的getter函数（用户指定的computed函数，如果没有设置getter，那么将当前指定的函数赋值computed属性的getter），进行上述的依赖收集
- 如果computed的属性值又依赖了其他computed计算属性值，那么会将当前target暂存到栈中，先进行其他computed计算属性值的依赖收集，等其他计算属性依赖收集完成后，在从栈中pop出来，继续进行当前computed的依赖收集

```js
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```

由于 `this.firstName` 和 `this.lastName` （上面是Vue官方示例）都是响应式变量，因此会触发它们的 getter，根据我们之前的分析，它们会把自身持有的 dep 添加到当前正在计算的 watcher 中，这个时候`Dep.target`就是这个 computed watcher，具体步骤如下：

- data 属性初始化 getter setter
- computed 计算属性初始化，提供的函数将用作属性 `vm.fullName` 的 getter
- 当首次获取 `fullName` 计算属性的值时，Dep 开始依赖收集
- 在执行 message getter 方法时，如果 Dep 处于依赖收集状态，则判定`firstName`和`lastName`为`fullName`  的依赖，并建立依赖关系
- 当`firstName`或`lastName` 发生变化时，根据依赖关系，触发 `fullName` 的重新计算
- 如果计算值没有发生变化，不会触发视图更新

通过以上的分析，我们知道计算属性本质上就是一个 computed watcher，也了解了它的创建过程和被访问触发 getter 以及依赖更新的过程，其实这是最新的计算属性的实现，之所以这么设计是因为 Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化才会触发渲染 watcher 重新渲染，本质上是一种优化。



### 10、Proxy 相比于 defineProperty 的优势

- 数组变化也能监听到
- 不需要深度遍历监听