---
title: js 知识点整理
date: 2019-07-02
sidebar: "auto"
categories:
  - front-end
tags:
  - interview
# keys:
#   - "bixin"
# publish: false
---

![img](https://i.loli.net/2020/02/12/pyc16anwe53xULV.jpg)



## 数据类型

[最新的 ECMAScript 标准定义了 8 种数据类型: ](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)

Boolean、Null、Undefined、Number、BigInt、String、Symbol 和 Object

#### 判断数据类型

- typeof：对于`null`及数组、对象，typeof均检测出为object
- instanceof：测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性
- constructor：undefined和null没有contructor属性；可被修改，所以不准确
- Object.prototype.toString.call



## var let const

| 声明方式 | 变量提升 | 暂时性死区 | 重复声明 | 初始值 | 作用域 |
| :------: | :------: | :--------: | :------: | :----: | :----: |
|   var    |   允许   |   不存在   |   允许   | 不需要 | 除块级 |
|   let    |  不允许  |    存在    |  不允许  | 不需要 |  块级  |
|  const   |  不允许  |    存在    |  不允许  |  需要  |  块级  |



## 类型转换

 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:

- -、*、/、% ：一律转换成数值后计算
- +： 
  - 数字 + 字符串 = 字符串， 运算顺序是从左到右
  - **数字 + 对象， 优先调用对象的`valueOf` -> `toString`**
  - 数字 + `boolean/null` -> 数字
  - 数字 + `undefined` -> `NaN`
- `[1].toString() === '1'`
- `{}.toString() === '[object object]'`
- `NaN` !== `NaN` 、`+undefined 为 NaN`



## new

#### 执行过程

- 新生成一个对象
- 链接到原型: `obj.__proto__ = Constructor.prototype`
- 绑定this: `apply`
- 返回新对象(如果构造函数有自己 retrun 时，则返回该值)

#### 代码实现

```js
const myNew = () => {
  let obj = {};
  let Constructor = [].shift.call(arguments);
  obj.__proto__ = Constructor.prototype;
  let result = Constructor.apply(obj, arguments);
  return result instanceof Object ? result : obj;
}
```



## this

由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是`this`。

1. 函数调用：this指向的是window
2. 方法调用：this指向调用当前方法的对象
3. 构造函数调用：如果函数是new调用的，此时this被绑定到创建出来的新对象上
4. 上下文调用：call、apply
5. 箭头函数：根据外部作用域来决定this



## 作用域

- 作用域其实可理解为该上下文中声明的 **变量和声明的作用范围**。可分为 **块级作用域** 和 **函数作用域**。js的作用域： **静态作用域（词法作用域）**，只管在哪声明，不管在哪调用
- 作用域链可以理解为一组对象列表，包含 **父级和自身的变量对象**。因此我们可以在执行上下文中访问到父级甚至全局的变量



## 闭包

**形象描述：当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量。**

- 产生条件：
  - 函数调用结束后函数的执行上下文销毁，内部变量会被释放。
  - 词法作用域：一个函数可以访问在它的调用上下文中定义的变量。

- 定义：父函数被销毁的情况下，返回出的子函数的`[[scope]]`中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。

- 闭包会产生一个很经典的问题:
  - 多个子函数的`[[scope]]`都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。

- 解决:
  - 变量可以通过 **函数参数的形式** 传入，避免使用默认的`[[scope]]`向上查找
  - 使用`setTimeout`包裹，通过第三个参数传入
  - 使用 **块级作用域**，让变量成为自己上下文的属性，避免共享



## 原型链

#### 组员

- **原型 prototype**：一个简单的对象，用于实现对象的 **属性继承**。可以简单的理解成对象的爹，通过`obj.__proto__`进行访问。

- **构造函数 constructor**： 可以通过`new`来 **新建一个对象** 的函数。

- **实例 instance**：通过构造函数和`new`创建出来的对象，便是实例。 **实例通过`__proto__`指向原型，通过`constructor`指向构造函数**。

#### 组员关系

```js
instance.__proto__ === prototype 

prototype.constructor === constructor 

constructor.prototype === prototype
```

#### 原型链

一个对象会有一个原型（`对象._proto_`）,同时这个原型也是一个对象，这个原型也会有原型，一环扣一环，就形成了一个链式的结构 ----- **原型链**。

- **属性查找机制**: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象`Object.prototype`，如还是没找到，则输出`undefined`；

- **属性修改机制**: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: `b.prototype.x = 2`；但是这样会造成所有继承于该对象的实例的属性发生改变。



## 继承

在 JS 中，继承通常指的便是 **原型链继承**，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。

![1LyEDg.png](https://s2.ax1x.com/2020/02/13/1LyEDg.png)

#### 寄生组合式继承

```js
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
function inheritPrototype(subType, superType) {
  var prototype = object(superType.prototype); // 创建对象
  prototype.constructor = subType; // 增强对象
  subType.prototype = prototype; // 指定对象
}
```

#### 优化

```js
const inherit = ((a, b) => {
  const F = function() {};
  return (a, b) => {
    F.prototype = b.prototype;
    a.prototype = new F();
    a.prototype.constructor = a;
  };
})();
```

#### test code

```js
function SuperType(name) {
  this.name = name;
  this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function() {
  console.log(this.name);
};
function SubType(name, age) {
  SuperType.call(this, name);
  this.age = age;
}

// inheritPrototype(SubType, SuperType);
inherit(SubType, SuperType);

SubType.prototype.sayAge = function() {
  console.log(this.age);
};

const a = new SubType('James',23)
a.sayName()
console.log(a.colors);
```

#### 使用 ES6 的语法糖 `class / extends`

[JavaScript常用八种继承方案](https://juejin.im/post/5bcb2e295188255c55472db0)

[一文吃透所有JS原型相关知识点](https://juejin.im/post/5dba456d518825721048bce9)



## JavaScript 执行机制

。。。



## 数组去重

```js
const uniq = arr => [...new Set(arr)];

const uniq = arr => arr.reduce((a, b) => (!a.includes(b) ? [...a, b] : a), []);

const uniq = arr => {
  let obj = {};
  return arr.filter(item =>
    obj.hasOwnProperty(typeof item + item)
      ? false
      : (obj[typeof item + item] = true)
  );
};
```
[如何答一道惊艳面试官的数组去重问题？](https://mp.weixin.qq.com/s/QqzVH8DRlsVGFyT69VdT2Q)

[JavaScript数组去重（12种方法，史上最全）](https://segmentfault.com/a/1190000016418021)



## 数组扁平 flat

```js
// 使用 flat
const flatten = arr => arr.flat(Infinity);

// 使用 reduce
const flatten = arr =>
  arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);

// 使用 reduce 实现 flat 可传入层数
const flatten = (arr, depth = 1) =>
  depth > 0
    ? arr.reduce(
        (a, b) => a.concat(Array.isArray(b) ? flatten(b, depth - 1) : b),
        []
      )
    : arr.slice();
```

[面试官连环追问：数组拍平（扁平化） flat 方法实现](https://mp.weixin.qq.com/s/xYbIBLR8uUM6krVDhQSHzw)



## 节流和防抖

#### 防抖

将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。

```js
function debounce(fn, wait, immediate) {
  let timer = null;
  return function(...args) {
    const context = this;
    if (immediate && !timer) {
      fn.apply(context, args);
      timer = 1;
    } else {
      clearTimeout(timer);
      timer = setTimeout(() => {
        fn.apply(context, args);
      }, wait);
    }
  };
}
```

#### 节流

每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。

```js
function throttle(fn, wait, immediate) {
  let timer = null;
  let callnow = immediate;
  return function(...args) {
    const context = this;
    if (callnow) {
      fn.apply(context, args);
      callnow = false;
    }
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(context, args);
        timer = null;
      }, wait);
    }
  };
}
```



## require 与 import

- `require`支持 **动态导入**；`import`不支持，正在提案 (babel 下可支持)
- `require`是 **同步** 导入；`import`属于 **异步** 导入
- `require`是 **值拷贝**，导出值变化不会影响导入值；`import`指向 **内存地址**，导入值会随导出值而变化



## AST

**抽象语法树 (Abstract Syntax Tree)**，是将代码逐字母解析成 **树状对象** 的形式。这是语言之间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础。








- promise & async
- 
