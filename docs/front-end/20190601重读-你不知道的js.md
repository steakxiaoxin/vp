---
title: 重读-你不知道的js
date: 2019-06-01
sidebar: "auto"
categories:
  - front-end
tags:
  - book
  - js
# keys:
#   - "bixin"
# publish: false
# sticky: true
---

![](https://i.loli.net/2020/01/03/DJkxabNREtVlw7y.jpg)

> 阅读流水账。

## 第一部分：作用域和闭包

### 一、作用域是什么

- 引擎

  从头到尾负责整个 JavaScript 程序的编译及执行过程。

- 编译器

  引擎的好朋友之一，负责语法分析及代码生成等脏活累活。

- 作用域

  引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

---

遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

---

当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。

LHS：查找的目的是对变量进行赋值

RHS：查找的目的是获取变量的值

```js
function foo(a) {
  var b = a;
  return a + b;
}
var c = foo(2);
```

<details>
  <summary>Answer</summary>
  1. 找出所有的 LHS 查询（这里有 3 处！） <br/>
  	c = ..;、a = 2（隐式变量分配）、b = .. <br/>
  2. 找出所有的 RHS 查询（这里有 4 处！）<br/>
  	foo(2..、= a;、a ..、.. b
</details>

小结：

- 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。
- 赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。 
- JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤： 

  1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 

  2. 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。 
- LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。 
- **不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。**

![](https://i.loli.net/2020/01/03/TGtZ8zuyBVorkLj.jpg)

---

### 二、词法作用域

**无论函数在哪里被如何调用，它的词法作用域都只由标识符(变量、函数)被声明时所处的位置决定。**

小结：

- 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。 

- JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。 

- 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。

![](https://i.loli.net/2020/01/03/rJxvjNplqt93Ywi.jpg)

---

### 三、函数作用域和块作用域

IIFE，代表立即执行函数表达式（Immediately Invoked Function Expression）

---

小结：

- 函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 

- 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。 

- 从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。 

- 在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。

- 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。

![](https://i.loli.net/2020/01/03/L3trU2OBeaTuYRI.jpg)

---

### 四、提升

任何声明在某个作用域内的变量，都将附属于这个作用域。

**函数优先**

---

小结：

- 我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 

- 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。

- 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 

- 要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！ 

![](https://i.loli.net/2020/01/03/g5UmwWkubAJEXrp.jpg)

---

### 五、作用域闭包

小结：

- **当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。** 

- 模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。

![img](https://user-gold-cdn.xitu.io/2018/5/29/163a995bb92570eb?imageslim)

## 第二部分：this 和对象原型

### 一、关于this

当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。

总结：

- **this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。** 

---

### 二、this 全面解析

判断方法：找到这个函数的直接调用位置。

判断规则：

1. 由 new 调用?绑定到新创建的对象。
2. 由 call 或者 apply (或者 bind )调用?绑定到指定的对象。
3. 由上下文对象调用?绑定到那个上下文对象。
4. 默认:在严格模式下绑定到 undefined ,否则绑定到全局对象。

ES6中的箭头函数并不会使用四条标准的绑定规则, 而是根据当前的词法作用域来决定 this ,具体来说,箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这 其实和 ES6 之前代码中的 self = this 机制一样。

![img](https://user-gold-cdn.xitu.io/2018/5/29/163a996bcbf28e91?imageslim)

---

### 三、对象

> 为什么 typeof null 时会返回字符串 "object"？其实是语言本身的一个 bug。原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。

在必要时语言会自动把字符串字面量转换成一个 String 对象，从而访问属性和方法。

在对象中，属性名永远都是字符串。

小结：

- JavaScript 中的对象有字面形式(比如 var a = { .. } )和构造形式(比如 var a = new Array(..) )。字面形式更常用,不过有时候构造形式可以提供更多选项。

- 许多人都以为“JavaScript 中万物都是对象”,这是错误的。对象是 6 个(或者是 7 个,取 决于你的观点)基础类型之一。对象有包括 function 在内的子类型,不同子类型具有不同 的行为,比如内部标签 [object Array] 表示这是对象的子类型数组。

- 对象就是键 / 值对的集合。可以通过 .propName 或者 ["propName"] 语法来获取属性值。访 问属性时, 引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]] ), [[Get]] 操作会检查对象本身是否包含这个属性,如果没找到的话还会查找 [[Prototype]] 链(参见第 5 章)。

- 属性的特性可以通过属性描述符来控制,比如 writable 和 configurable 。此外,可以使用 Object.preventExtensions(..) 、 Object.seal(..) 和 Object.freeze(..) 来设置对象(及其 属性)的不可变性级别。

- 属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外,属性可以是 可枚举或者不可枚举的,这决定了它们是否会出现在 for..in 循环中。

- 你可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象, 等等)中的值, for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。

![](https://i.loli.net/2020/01/06/NCmL95v7EfGwpx2.jpg)
![](https://i.loli.net/2020/01/06/nAvbWNMXGuVRlsZ.jpg)

---

### 四、混合对象"类"

小结：

- 类是一种设计模式。 许多语言提供了对于面向类软件设计的原生语法。 JavaScript 也有类 似的语法,但是和其他语言中的类完全不同。

- 类意味着复制。

- 传统的类被实例化时,它的行为会被复制到实例中。类被继承时,行为也会被复制到子类 中。

- 多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父 类,但是本质上引用的其实是复制的结果。

- JavaScript 并不会(像类那样)自动创建对象的副本。

- 混入模式(无论显式还是隐式)可以用来模拟类的复制行为,但是通常会产生丑陋并且脆 弱的语法,比如显式伪多态( OtherObj.methodName.call(this, ...) ),这会让代码更加难 懂并且难以维护。

- 此外, 显式混入实际上无法完全模拟类的复制行为, 因为对象(和函数!别忘了函数也 是对象)只能复制引用, 无法复制被引用的对象或者函数本身。 忽视这一点会导致许多 问题。

- 总地来说,在 JavaScript 中模拟类是得不偿失的,虽然能解决当前的问题,但是可能会埋下更多的隐患。

![image.png](https://i.loli.net/2020/01/07/aHEfQojC3nMSryh.png)

---

### 五、原型

小结：

- 如果要访问对象中并不存在的一个属性，[[Get]] 操作（参见第 3 章）就会查找对象内部[[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”（有点像嵌套的作用域链），在查找属性时会对它进行遍历。

- 所有普通对象都有内置的 Object.prototype ,指向原型链的顶端(比如说全局作用域),如果在原型链中找不到指定的属性就会停止。 toString() 、 valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上,因此语言中所有的对象都可以使用它们。

- 关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤（第 2 章）中会创建一个关联其他对象的新对象。

- 使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”。带 new 的函数调用通常被称为“构造函数调用”,尽管它们实际上和传统面向类语言中的 类构造函数 不一样。

- 虽然这些 机制和传统面向类语言中的“类初始化”和“类继承”很相似, 但是 javascript 机制和传统面向对象类语言中的“类初始化”和“类继承”很相似但是 javascript 中的机制有一个核心区别，就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。

- 出于各种原因,以“继承”结尾的术语(包括“原型继承”)和其他面向对象的术语都无法帮助你理解 JavaScript 的 真实 机制(不仅仅是限制我们的思维模式)。

- 相比之下,“委托”是一个更合适的术语,因为对象之间的关系不是复制而是委托。

![image.png](https://i.loli.net/2020/01/07/XDBiLm47VATM9QJ.png)

![image.png](https://i.loli.net/2020/01/07/eflLPts81nBE7Yi.png)

---

### 六、行为委托

小结：

- 在软件架构中你可以 选择是否 使用类和继承设计模式。大多数开发者理所当然地认为类是 唯一(合适)的代码组织方式,但是本章中我们看到了另一种更少见但是更强大的设计模式: 行为委托 。

- 行为委托认为对象之间是兄弟关系, 互相委托, 而不是父类和子类的关系。 JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。也就是说,我们可以选择在 JavaScript 中努 力实现类机制(参见第 4 和第 5 章),也可以拥抱更自然的 [[Prototype]] 委托机制。

- 当你只用对象来设计代码时,不仅可以让语法更加简洁,而且可以让代码结构更加清晰。

- 对象关联(对象之前互相关联)是一种编码风格,它倡导的是直接创建和关联对象,不把 它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。

![image.png](https://i.loli.net/2020/01/07/7MpWBRJNzbFvohS.png)

---

<details>
  <summary><b>上卷结束</b></summary>
  (越看越迷)
</details>

[todo](https://juejin.im/post/5b2a07c16fb9a00e36425ef0)



## 第三部分：类型和语法

### 一、类型

小结：

- JavaScript 有 七 种 内 置 类 型：null、undefined、boolean、number、string、object 和 symbol，可以使用 typeof 运算符来查看。 
- 变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。 
- 很多开发人员将 undefined 和 undeclared 混为一谈，但在 JavaScript 中它们是两码事。 undefined 是值的一种。undeclared 则表示变量还没有被声明过。 
- 遗憾的是，JavaScript 却将它们混为一谈，在我们试图访问 "undeclared" 变量时这样报错：ReferenceError: a is not defifined，并且 typeof 对 undefifined 和 undeclared 变量都返回"undefined"。 
- 然而，通过 typeof 的安全防范机制（阻止报错）来检查 undeclared 变量，有时是个不错的办法。

![image.png](https://i.loli.net/2020/01/13/6jD7lNZK2ng4a3V.png)